# 快速幂算法详细教学

快速幂算法（Exponentiation by Squaring）是一种高效计算幂次的方法，特别适用于大整数运算，时间复杂度为 $O(\log n)$。本文将从原理、代码实现、应用场景和经典例题等多个方面，全面解析快速幂算法。

## 一、快速幂算法的基本原理

### 分治思想

快速幂的核心在于利用指数的二进制表示，将问题分治成更小的问题来解决：

- **偶数指数**：
  如果 $b$ 是偶数，则 $a^b = (a^{b/2})^2$。
  - 例：$a^{10} = (a^5)^2$。

- **奇数指数**：
  如果 $b$ 是奇数，则 $a^b = a \times a^{b-1}$。
  - 例：$a^5 = a \times a^4 = a \times (a^2)^2$。

- **递归终止条件**：
  当 $b=0$ 时，结果为 1，因为 $a^0=1$。

## 二、快速幂的代码实现

### 1. 迭代法实现

这种方法通过循环实现快速幂运算。

```c++
#include <iostream>
using namespace std;

// 快速幂函数：计算 a^b
int qp(int a, int b) {
    int r = 1;         // r 存储结果，初始为 1
    while (b > 0) {    // 当指数 b 大于 0 时继续循环
        if (b % 2)     // 如果 b 是奇数
            r *= a;    // 将当前基数累乘到结果
        a *= a;        // 基数自乘
        b /= 2;        // 指数减半
    }
    return r;          // 返回计算结果
}

int main() {
    int a, b;
    cout << "输入底数和指数：";
    cin >> a >> b;              // 输入底数 a 和指数 b
    cout << a << "^" << b << " = " << qp(a, b) << endl;
    return 0;
}
```
### 2. 递归法实现
递归法基于分治思想
```c++
#include <iostream>
using namespace std;

// 快速幂函数：递归实现
int qp(int a, int b) {
    if (b == 0) return 1;        // 边界条件：a^0 = 1
    if (b % 2 == 0)              // 如果 b 是偶数
        return qp(a * a, b / 2); // a^b = (a^2)^(b/2)
    else                         // 如果 b 是奇数
        return a * qp(a * a, b / 2); // a^b = a * (a^2)^(b/2)
}

int main() {
    int a, b;
    cout << "输入底数和指数：";
    cin >> a >> b;              // 输入底数和指数
    cout << a << "^" << b << " = " << qp(a, b) << endl;
    return 0;
}
```
### 3. 快速幂取模实现
快速幂取模算法是一种在计算机中快速计算大整数模运算的方法。它利用了快速幂算法的原理，通过将大整数的指数分解为二进制形式，然后逐位计算，最后取模。
在实际问题中，幂次运算容易导致数据溢出，通常结合模运算来求解。
```c++
#include <iostream>
using namespace std;

// 快速幂取模函数：计算 (a^b) % c
int mod_qp(int a, int b, int c) {
    int r = 1;                // 初始化结果 r 为 1
    a %= c;                   // 先对 a 取模，避免溢出
    while (b > 0) {           // 当 b > 0 时继续
        if (b % 2)            // 如果 b 是奇数
            r = (r * a) % c;  // 累乘并取模
        a = (a * a) % c;      // 基数平方并取模
        b /= 2;               // 指数减半
    }
    return r;                 // 返回结果
}

int main() {
    int a, b, c;
    cout << "输入底数、指数和模数：";
    cin >> a >> b >> c;       // 输入 a, b 和 c
    cout << "(" << a << "^" << b << ") % " << c << " = " << mod_qp(a, b, c) << endl;
    return 0;
}
```

### 三、快速幂的应用场景

 **算法优化**： 1. 快速幂算法可以用于优化算法，例如在矩阵乘法中，快速幂算法可以用于计算矩阵的幂次，从而提高算法的效率。
               2.  用于解决递推问题（如斐波那契数列的快速计算）
### 四、快速幂的经典例题
#### 洛谷：[p1226 求模幂](https://www.luogu.com.cn/problem/p1226]
# 【模板】快速幂

## 题目描述

给你三个整数 $a,b,p$，求 $a^b \bmod p$。

## 输入格式

输入只有一行三个整数，分别代表 $a,b,p$。

## 输出格式

输出一行一个字符串 `a^b mod p=s`，其中 $a,b,p$ 分别为题目给定的值， $s$ 为运算结果。

## 样例 #1

### 样例输入 #1

```
2 10 9
```

### 样例输出 #1

```
2^10 mod 9=7
```

## 提示

**样例解释**

$2^{10} = 1024$，$1024 \bmod 9 = 7$。

**数据规模与约定**

对于 $100\%$ 的数据，保证 $0\le a,b < 2^{31}$，$a+b>0$，$2 \leq p \lt 2^{31}$。

----------------------------------------------------------------------------------------------
#### 题解（此题方法繁多，如二分，位运算等等，建议移步洛谷题解区）

>来自Catreap大佬的题解

快速幂是什么？  
就是能把  
pow(num) 算法效率达到 O(log2N)。  

利用的就是二进制 。  

我们可以把 ab 中的 b 拆成二进制，该二进制数第i位的权值是2^(i-1)  

E.X. 当 b=11时， a11 = a2^0+2^1+2^3 ，很简单吧？  

Why 11的二进制是 1011， 11=2^3×1+2^2×0+2^1×1+2^1×1  

因此，我们将 a11 转化为算 a2^0+2^1+2^3 ，看出来快的多了吧原来算11次，现在算三次，那么怎么算个数？  

有一个神奇的操作 **&1**:取二进制的最末位,还可以判断奇偶。  

还有一个神奇的操作 **>>1**:二进制去掉最后一位。  

其实也很好理解，以b=11为例，b=>1011,二进制从右向左算，顺序是 a2^0×a2^1×a2^3 ，是从左向右的，我们不断的让 base 累乘即可。  

```cpp
ll Pow(ll a,ll b) {
	ll sum=1;//一定要初始化为1，不然返回0
	while(b) {//b!=0执行
    	//如果末位为1累乘
		if(b&1) sum=sum*a%Mod;//取MOD，题目要求
		a=a*a%Mod,b>>=1;//每操作一次，去掉末位
	}
	return sum;
}
```
----------------------------------------------------------------------------------------------
我的分享到此结束了，希望对大家有帮助。
